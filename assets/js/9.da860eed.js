(window.webpackJsonp=window.webpackJsonp||[]).push([[9],{378:function(t,e,n){"use strict";n.r(e);var a=n(42),i=Object(a.a)({},(function(){var t=this,e=t.$createElement,n=t._self._c||e;return n("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[n("h1",{attrs:{id:"api-geometry-classes"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#api-geometry-classes"}},[t._v("#")]),t._v(" API Geometry Classes")]),t._v(" "),n("p",[t._v("In general, the constructors are very flexible in accepting the varying and mixed geometry formats. The geometry input is parsed recursively, so in almost all cases if it makes sense logically, the constructor will parse it.")]),t._v(" "),n("h2",{attrs:{id:"spatial-reference"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#spatial-reference"}},[t._v("#")]),t._v(" Spatial Reference")]),t._v(" "),n("p",[t._v("This is fairly in-line with ESRI's format. It supports WKID and WKT, and optional latestWKID parameters.")]),t._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[t._v('const lambertSR = new RAMP.GEO.SpatialReference(3978);\nconst fancySRwithLatest = new RAMP.GEO.SpatialReference(102100, 3857);\nconst azimuthSR = new RAMP.GEO.SpatialReference(\'PROJCS["Sphere_ARC_INFO_Azimuthal_Equidistant",GEOGCS["GCS_Sphere_ARC_INFO",DATUM["D_Sphere_ARC_INFO",SPHEROID["Sphere_ARC_INFO",6370997.0,0.0]],PRIMEM["Greenwich",0.0],UNIT["Degree",0.0174532925199433]],PROJECTION["Azimuthal_Equidistant"],PARAMETER["False_Easting",0.0],PARAMETER["False_Northing",0.0],PARAMETER["Central_Meridian",-90.0],PARAMETER["Latitude_Of_Origin",90.0],UNIT["Meter",1.0]]\');\nconst iAmFalse = lambertSR.isEqual(aziumthSR);\n')])])]),n("h2",{attrs:{id:"point"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#point"}},[t._v("#")]),t._v(" Point")]),t._v(" "),n("p",[t._v("Various co-ordinate inputs of the constructors.")]),t._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[t._v("const pt1 = new RAMP.GEO.Point('myid', [-76.77, 44.42]);\nconst pt2 = new RAMP.GEO.Point('myid', {x: -76.77, y: 44.42});\nconst pt3 = new RAMP.GEO.Point('myid', pt2);\nconst pt4 = new RAMP.GEO.Point('myid', [-76.77, '44.42']);\nconst pt5 = new RAMP.GEO.Point('myid', {x: '-76.77', y: 44.42});\n")])])]),n("p",[t._v("Various methods")]),t._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[t._v("const pt = new RAMP.GEO.Point('myid', [-76.77, 44.42]);\npt.type; // 'Point'\npt.id; // 'myid'\npt.sr; // { wkid: 4326 }\npt.x; // -76.77\npt.y; // 44.42\npt.toArray(); // [-76.77, 44.42]\npt.x = -77.13; // point has updated.\n")])])]),n("h3",{attrs:{id:"spatial-references-on-geometry"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#spatial-references-on-geometry"}},[t._v("#")]),t._v(" Spatial References on Geometry")]),t._v(" "),n("p",[t._v("The optional constructor parameter for spatial references is available on all geometry. We will use "),n("code",[t._v("Point")]),t._v(" to illustrate.")]),t._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[t._v("const lambertSR = new RAMP.GEO.SpatialReference(3978);\nconst lambertPt1 = new RAMP.GEO.Point('myid', [1461066.3, -303263.6], lambertSR);\nconst lambertPt2 = new RAMP.GEO.Point('myid', [1461066.3, -303263.6], 3978);\nconst lambertPt3 = new RAMP.GEO.Point('myid', lambertPt); // Note no explicit spatial reference passed in. Single RAMP geometry inputs provide their SR to the new instance\nconst badLambertPt = new RAMP.GEO.Point('myid', [1461066.3, -303263.6]); // will have lambert values and Lat-Long spatial reference\nconst wktPt = new RAMP.GEO.Point('myid', [123, 456], 'wkt string value');\n")])])]),n("h3",{attrs:{id:"raw-input-for-geometry"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#raw-input-for-geometry"}},[t._v("#")]),t._v(" Raw Input for Geometry")]),t._v(" "),n("p",[t._v("If the co-ordinate input is a well formed array of numbers (including that all polygon rings are closed), we can leverage the optional "),n("code",[t._v("raw")]),t._v(" flag on the constructor. This is an efficiency flag, indicating the data can be consumed as is, there is no need to validate and parse the values. This option exists for all geometry types except "),n("code",[t._v("Extent")]),t._v(". If in doubt of the array format, it will always match the output of the "),n("code",[t._v(".toArray()")]),t._v(" method of the particular geometry type.")]),t._v(" "),n("p",[t._v("While our "),n("code",[t._v("Point")]),t._v(" example may seem trivial, performance gains are to be had when dealing with geometries having high vertex counts.")]),t._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[t._v("const lambertPt = new RAMP.GEO.Point('myid', [1461066.3, -303263.6], 3978, true);\n")])])]),n("h2",{attrs:{id:"multipoint"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#multipoint"}},[t._v("#")]),t._v(" MultiPoint")]),t._v(" "),n("p",[t._v("Various co-ordinate inputs of the constructors.")]),t._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[t._v("const mptFromCoords = new RAMP.GEO.MultiPoint('myid', [[-76.77, 44.42], [-68.69, 51.39]]);\nconst mptFromMultiPt = new RAMP.GEO.MultiPoint('myid', mptFromCoords);\nconst pt = new RAMP.GEO.Point('myid', [-76.77, 44.42]);\nconst mptMixedPoints = new RAMP.GEO.MultiPoint('myid', [pt, [-68.69, 51.39], {x: \"-97.86\", y: 55.74}]);\n")])])]),n("p",[t._v("Various methods")]),t._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[t._v("const mpt = new RAMP.GEO.MultiPoint('myid', [[-76.77, 44.42], [-68.69, 51.39]]);\nmpt.type;                // 'MultiPoint'\nmpt.id;                  // 'myid'\nmpt.sr;                  // { wkid: 4326 }\nmpt.length;              // 2\nmpt.pointArray;          // [Point, Point] where each Point corresponds to the co-ords and is typed as RAMP API Point. These Points are not bound to the MultiPoint.\nmpt.toArray();           // [[-76.77, 44.42], [-68.69, 51.39]]\n\nconst pt = mpt.getAt(0); // Point corresponding to -76.77, 44.42. This object is not bound to the MultiPoint\npt.x = -78.22;           // pt has updated, mpt has not\nmpt.updateAt(pt, 0);     // multipoint innards are now [[-78.22, 44.42], [-68.69, 51.39]]\n")])])]),n("h2",{attrs:{id:"line-string"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#line-string"}},[t._v("#")]),t._v(" Line String")]),t._v(" "),n("p",[t._v("This has effectively the same interface as "),n("code",[t._v("MultiPoint")]),t._v(", so examples will be sparse. "),n("code",[t._v("LineString")]),t._v(" enforces a minimum of two vertices.")]),t._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[t._v("const lineFromCoords = new RAMP.GEO.LineString('myid', [[-76.77, 44.42], [-68.69, 51.39]]);\nconst lineFromLine = new RAMP.GEO.LineString('myid', lineFromCoords); // also accepts MultiPoint\nlineFromCoords.type; // 'LineString'\n")])])]),n("h2",{attrs:{id:"linear-ring"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#linear-ring"}},[t._v("#")]),t._v(" Linear Ring")]),t._v(" "),n("p",[t._v("This also has effectively the same interface as "),n("code",[t._v("MultiPoint")]),t._v(". "),n("code",[t._v("LinearRing")]),t._v(" enforces that the last vertex must be identical to the first vertex. However, being both smart and kind, the constructor will inject a closing vertex if it is missing from the source. After closure, "),n("code",[t._v("LinearRing")]),t._v(" expects a minimum of four vertices. For optimal drawing, the vertices should be in a clockwise order.")]),t._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[t._v("const ringIncomplete = new RAMP.GEO.LinearRing('myid', [[-76.77, 44.42], [-97.86, 55.74], [-68.69, 51.39]]);\nringIncomplete.toArray(); // [[-76.77, 44.42], [-97.86, 55.74], [-68.69, 51.39], [-76.77, 44.42]]\nringIncomplete.type;      // 'LinearRing'\n")])])]),n("h2",{attrs:{id:"multi-line-string"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#multi-line-string"}},[t._v("#")]),t._v(" Multi Line String")]),t._v(" "),n("p",[t._v("Various co-ordinate inputs of the constructors.")]),t._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[t._v("const mlsFromCoords = new RAMP.GEO.MultiLineString('myid', [[[-76.77, 44.42], [-80.95, 49.96], [-68.69, 51.39]], [[-97.86, 55.74], [-82.15, 49.34]]]);\nconst mlsFromMultiLine = new RAMP.GEO.MultiLineString('myid', mlsFromCoords); // also accepts LineString, MultiPoint\nconst line = new RAMP.GEO.LineString('myid', [[-97.86, 55.74], [-82.15, 49.34]]);\nconst point = new RAMP.GEO.Point('myid', [-68.69, 51.39]);\nconst mlsFromMixedLines = new RAMP.GEO.MultiLineString('myid', [[[-76.77, \"44.42\"], {x: \"-80.95\", y: 49.96}, point], line]);\n")])])]),n("p",[t._v("Various methods")]),t._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[t._v("const mls = new RAMP.GEO.MultiLineString('myid', [[[-76.77, 44.42], [-80.95, 49.96], [-68.69, 51.39]], [[-97.86, 55.74], [-82.15, 49.34]]]);\nmls.type;                // 'MultiLineString'\nmls.id;                  // 'myid'\nmls.sr;                  // { wkid: 4326 }\nmls.length;              // 2\nmls.lineArray;           // [LineString, LineString] where each LineString corresponds to the line co-ords and is typed as RAMP API LineString. These LineStrings are not bound to the MultiLineString.\nmls.toArray();           // [[[-76.77, 44.42], [-80.95, 49.96], [-68.69, 51.39]], [[-97.86, 55.74], [-82.15, 49.34]]]\n\nconst ln = mls.getAt(1); // Line corresponding to [-97.86, 55.74], [-82.15, 49.34]. This object is not bound to the MultiLineString\nconst pt = new RAMP.GEO.Point('pt', [-99, 55]);\nln.updateAt(pt, 0);\nmls.updateAt(ln, 1);     // multilinestring innards are now [[[-76.77, 44.42], [-80.95, 49.96], [-68.69, 51.39]], [[-99, 55], [-82.15, 49.34]]]\n")])])]),n("h2",{attrs:{id:"polygon"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#polygon"}},[t._v("#")]),t._v(" Polygon")]),t._v(" "),n("p",[t._v("Various co-ordinate inputs of the constructors.")]),t._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[t._v("const polyFromCoords = new RAMP.GEO.Polygon('myid', [[[-76.77, 44.42], [-80.95, 49.96], [-68.69, 51.39], [-76.77, 44.42]], [[-97.86, 55.74], [-82.15, 49.34], [-116.95, 51.30], [-97.86, 55.74]]]);\nconst polyFromPoly = new RAMP.GEO.Polygon('myid', polyFromCoords); // also accepts MultiLineString, LinearRing, LineString, MultiPoint\nconst line = new RAMP.GEO.MultiPoint('myid', [[-97.86, 55.74], [-82.15, 49.34], [-76.77, 44.42]]);\nconst point = new RAMP.GEO.Point('myid', [-68.69, 51.39]);\nconst polyFromMixedUnclosedRings = new RAMP.GEO.Polygon('myid', [[[-116.95, 51.30], point, {x: \"-80.95\", y: 49.96}], line]);\n")])])]),n("p",[t._v("Various methods")]),t._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[t._v("const poly = new RAMP.GEO.Polygon('myid', [[[-76.77, 44.42], [-80.95, 49.96], [-68.69, 51.39]], [[-97.86, 55.74], [-82.15, 49.34], [-116.95, 51.30]]]);\npoly.type;                // 'Polygon'\npoly.id;                  // 'myid'\npoly.sr;                  // { wkid: 4326 }\npoly.length;              // 2\npoly.ringArray;           // [LinearRing, LinearRing] where each LinearRing corresponds to the ring co-ords (including closing vertex) and is typed as RAMP API LinearRing. These LinearRings are not bound to the Polygon.\npoly.toArray();           // [[[-76.77, 44.42], [-80.95, 49.96], [-68.69, 51.39], [-76.77, 44.42]], [[-97.86, 55.74], [-82.15, 49.34], [-116.95, 51.30], [-97.86, 55.74]]]\n\nconst lr = new RAMP.GEO.LinearRing('lr', [[-97.86, 55.74], [-88, 44], [-116.95, 51.30]]);\npoly.addLinearRings([lr]); // new ring is added\n")])])]),n("p",[t._v("odds are more methods will be added to Polygon, including the "),n("code",[t._v("getAt()")]),t._v(" and "),n("code",[t._v("updateAt()")]),t._v(" that are present on other geometries.")]),t._v(" "),n("h2",{attrs:{id:"multipolygon"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#multipolygon"}},[t._v("#")]),t._v(" MultiPolygon")]),t._v(" "),n("p",[t._v("Various co-ordinate inputs of the constructors.")]),t._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[t._v("const mpyFromCoords = new RAMP.GEO.MultiPolygon('myid', [[[[-76.77, 44.42], [-80.95, 49.96], [-68.69, 51.39], [-76.77, 44.42]]], [[[-97.86, 55.74], [-82.15, 49.34], [-116.95, 51.30], [-97.86, 55.74]]]]);\nconst mpyFromMPoly = new RAMP.GEO.MultiPolygon('myid', mpyFromCoords); // also accepts Polygon, MultiLineString, LinearRing, LineString, MultiPoint\n// the examples are getting large, so omitted, but rest assured the constructor will accept an array of mixed formats that equate to Polygon-esque structures\n")])])]),n("p",[t._v("Various methods")]),t._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[t._v("const mpy = new RAMP.GEO.MultiPolygon('myid', [[[[-76.77, 44.42], [-80.95, 49.96], [-68.69, 51.39]]], [[[-97.86, 55.74], [-82.15, 49.34], [-116.95, 51.30]]]]);\nmpy.type;                // 'MultiPolygon'\nmpy.id;                  // 'myid'\nmpy.sr;                  // { wkid: 4326 }\nmpy.length;              // 2\nmpy.polygonArray;        // [Polygon, Polygon] where each Polygon corresponds to the polygon co-ords and is typed as RAMP API Polygon. These Polygons are not bound to the MultiPolygon.\nmpy.toArray();           // [[[[-76.77, 44.42], [-80.95, 49.96], [-68.69, 51.39], [-76.77, 44.42]]], [[[-97.86, 55.74], [-82.15, 49.34], [-116.95, 51.30], [-97.86, 55.74]]]]\n\nconst poly = new RAMP.GEO.Polygon('p', [[[-97.86, 55.74], [-88, 44], [-116.95, 51.30]]]);\nmpy.addPolygon(poly); // new polygon is added\n")])])]),n("p",[t._v("odds are more methods will be added to MultiPolygon, including the "),n("code",[t._v("getAt()")]),t._v(" and "),n("code",[t._v("updateAt()")]),t._v(" that are present on other geometries.")]),t._v(" "),n("p",[t._v("more to be added...")])])}),[],!1,null,null,null);e.default=i.exports}}]);